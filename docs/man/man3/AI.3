.TH "AI" 3 "Mon Feb 15 2021" "S.S.E.H.C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AI
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBevaluation\fP (\fBBoard\fP &board)"
.br
.ti -1c
.RI "int \fBflippedEval\fP (\fBBoard\fP &board)"
.br
.ti -1c
.RI "void \fBsendPV\fP (\fBBoard\fP &board, int depth, \fBCMove\fP pv_move, int node_count, \fBScore\fP score, std::chrono::_V2::system_clock::time_point start)"
.br
.ti -1c
.RI "\fBCMove\fP \fBrootMove\fP (\fBBoard\fP &board, int depth, std::atomic< bool > &stop, \fBScore\fP &out_score, \fBCMove\fP prevPv, int &count, std::chrono::_V2::system_clock::time_point start, std::vector< \fBMoveScoreTuple\fP > &prevScores)"
.br
.ti -1c
.RI "\fBScore\fP \fBquiescence\fP (\fBBoard\fP &board, int depth, int ply_count, \fBScore\fP alpha, \fBScore\fP beta, std::atomic< bool > &stop, int &count, int kickoff)"
.br
.ti -1c
.RI "\fBScore\fP \fBalphaBetaSearch\fP (\fBBoard\fP &board, int depth, int ply_count, \fBScore\fP alpha, \fBScore\fP beta, std::atomic< bool > &stop, int &count, \fBNodeType\fP my_node_type, bool is_save)"
.br
.ti -1c
.RI "\fBScore\fP \fBzeroWindowSearch\fP (\fBBoard\fP &board, int depth, int ply_count, \fBScore\fP beta, std::atomic< bool > &stop, int &count, \fBNodeType\fP my_node_type)"
.br
.ti -1c
.RI "\fBMoveList\fP< 256 > \fBgenerateMovesOrdered\fP (\fBBoard\fP &board, \fBCMove\fP hash_move, int ply_count, int &num_positive_moves)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBNodeType\fP \fBPV\fP = 0"
.br
.ti -1c
.RI "const \fBNodeType\fP \fBCut\fP = 1"
.br
.ti -1c
.RI "const \fBNodeType\fP \fBAll\fP = 2"
.br
.ti -1c
.RI "const int \fBSCORE_MIN\fP = std::numeric_limits<int>::\fBmin\fP()"
.br
.ti -1c
.RI "const int \fBSCORE_MAX\fP = std::numeric_limits<int>::\fBmax\fP()"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBScore\fP AI::alphaBetaSearch (\fBBoard\fP & board, int depth, int ply_count, \fBScore\fP alpha, \fBScore\fP beta, std::atomic< bool > & stop, int & count, \fBNodeType\fP my_node_type, bool is_save)"

.SS "int AI::evaluation (\fBBoard\fP & board)"

.SS "int AI::flippedEval (\fBBoard\fP & board)"

.SS "\fBMoveList\fP<256> AI::generateMovesOrdered (\fBBoard\fP & board, \fBCMove\fP hash_move, int ply_count, int & num_positive_moves)"

.SS "\fBScore\fP AI::quiescence (\fBBoard\fP & board, int depth, int ply_count, \fBScore\fP alpha, \fBScore\fP beta, std::atomic< bool > & stop, int & count, int kickoff)"

.SS "\fBCMove\fP AI::rootMove (\fBBoard\fP & board, int depth, std::atomic< bool > & stop, \fBScore\fP & out_score, \fBCMove\fP prevPv, int & count, std::chrono::_V2::system_clock::time_point start, std::vector< \fBMoveScoreTuple\fP > & prevScores)"

.SS "void AI::sendPV (\fBBoard\fP & board, int depth, \fBCMove\fP pv_move, int node_count, \fBScore\fP score, std::chrono::_V2::system_clock::time_point start)"

.SS "\fBScore\fP AI::zeroWindowSearch (\fBBoard\fP & board, int depth, int ply_count, \fBScore\fP beta, std::atomic< bool > & stop, int & count, \fBNodeType\fP my_node_type)"

.SH "Variable Documentation"
.PP 
.SS "const \fBNodeType\fP AI::All = 2"

.SS "const \fBNodeType\fP AI::Cut = 1"

.SS "const \fBNodeType\fP AI::PV = 0"

.SS "const int AI::SCORE_MAX = std::numeric_limits<int>::\fBmax\fP()"

.SS "const int AI::SCORE_MIN = std::numeric_limits<int>::\fBmin\fP()"

.SH "Author"
.PP 
Generated automatically by Doxygen for S\&.S\&.E\&.H\&.C from the source code\&.
